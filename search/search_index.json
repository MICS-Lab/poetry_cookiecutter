{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This repository eases the creation of a new Python package. Using cookiecutter , it will copy the project template and personalize it according to the answers to a few questions (e.g. the project name) so that you can get started quickly. Features Easy dependency management with Poetry . Pretty documentation with Mkdocs material . Package installable on any local environment (package structure). Deployment on PyPI in a few seconds, if needed. Tests with pytest . Formatting with black . Standardized project organization ( data folder, config folder, ...). Project structure Once created, your package structure will look like that: . |-- LICENSE |-- README.md |-- config # folder containing your config files |-- data # folder containing your data files |-- docs # your documentation | |-- index.md | `-- ... |-- mkdocs.yml # documentation config |-- poetry.lock # poetry-related file (do not update) |-- <your-module-name> # folder containing your code | |-- __init__.py | `-- ... |-- pyproject.toml # project dependency settings and config |-- setup.py # setup file to enable installation with pip `-- tests # folder to write your package tests `-- test_instance.py","title":"Home"},{"location":"#features","text":"Easy dependency management with Poetry . Pretty documentation with Mkdocs material . Package installable on any local environment (package structure). Deployment on PyPI in a few seconds, if needed. Tests with pytest . Formatting with black . Standardized project organization ( data folder, config folder, ...).","title":"Features"},{"location":"#project-structure","text":"Once created, your package structure will look like that: . |-- LICENSE |-- README.md |-- config # folder containing your config files |-- data # folder containing your data files |-- docs # your documentation | |-- index.md | `-- ... |-- mkdocs.yml # documentation config |-- poetry.lock # poetry-related file (do not update) |-- <your-module-name> # folder containing your code | |-- __init__.py | `-- ... |-- pyproject.toml # project dependency settings and config |-- setup.py # setup file to enable installation with pip `-- tests # folder to write your package tests `-- test_instance.py","title":"Project structure"},{"location":"getting_started/","text":"Requirements Python >= 3.7 Git Poetry (if the command line below doesn't work, see here ): For Linux / MacOS For Windows (Powershell) curl -sSL https://install.python-poetry.org | python3 - ( Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing ) .Content | py - Cookiecutter (don't create a new environment, poetry will take care of that): With pip With conda pip install cookiecutter conda install cookiecutter Usage Info After answering a few questions, the command line below creates a new folder with everything you need inside. Especially, it created a README.md file that helps you understand the package organization you just created. Run the following command line to create a new project folder. Note that it will put everything inside a new folder; thus, you don't have to mkdir first. cookiecutter gh:MICS-Lab/poetry_cookiecutter","title":"Getting started"},{"location":"getting_started/#requirements","text":"Python >= 3.7 Git Poetry (if the command line below doesn't work, see here ): For Linux / MacOS For Windows (Powershell) curl -sSL https://install.python-poetry.org | python3 - ( Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing ) .Content | py - Cookiecutter (don't create a new environment, poetry will take care of that): With pip With conda pip install cookiecutter conda install cookiecutter","title":"Requirements"},{"location":"getting_started/#usage","text":"Info After answering a few questions, the command line below creates a new folder with everything you need inside. Especially, it created a README.md file that helps you understand the package organization you just created. Run the following command line to create a new project folder. Note that it will put everything inside a new folder; thus, you don't have to mkdir first. cookiecutter gh:MICS-Lab/poetry_cookiecutter","title":"Usage"},{"location":"good_practices/","text":"This page is a non-exhaustive list of good practices in Python. These good practices follow the PEP 8 style guide , which we advise you to read. Naming conventions In Python, the most common cases are: snake_case (lower case separated by a _ ), PascalCase (capital letters as a separation, including the first word), and UPPER_CASE . The usages are the following: snake_case for file names, folder names, variables, functions, methods, objects, and your package name. PascalCase to define classes and exceptions. UPPER_CASE for constants. Note For protected methods and internal functions, you can use a _ before, e.g. _my_function . For private methods, use two _ , e.g. __my_method . Code readability We listed below some advice to make the code easier to read. Use _ to name a variable that will not be used: it avoids overloading your brain while reading the code. For instance, if we are only interested in the first value of a tuple: a, _ = f() , or if you don't need the index in a for loop: for _ in range(10): Remove all your unused imports. It makes the code shorter, faster, and easier to read. Avoid having many nested loops. Instead, you can refactor your code to return early or make new functions. We recommend having at most two levels of nested indentation inside functions/methods. Type hints We recommend using type hints inside each function and method (see PEP guidelines ). Two basic examples can be found below. Note When nothing is returned, None can be used as the function output type. Also, some typings can be imported from typing , e.g. List . from typing import List def greeting ( name : str ) -> None : print ( f 'Hello { name } !' ) def list_multiplication ( l : List [ float ], a : int ) -> List [ float ]: return [ a * x for x in l ] There are many advantages of type hints. In particular, it: enables code completion is less error-prone (since your IDE may help you track bugs before they happen) improves readability guide the user to understand the input/output of any function Catching wrong inputs It's great to run a sanity check before running some functions to ensure every argument satisfies some constraints. When the arguments don't meet the constraints, you can return a meaningful error message, saving you a lot of bug-fixing time. from model import MyModel def f ( x : MyModel , a : float ): assert isinstance ( x , MyModel ), f \"The argument 'x' has to be a MyModel object, but found { type ( x ) } .\" assert 0 < a < 1 , f \"The argument 'a' should be included in ]0, 1[, but found { a } .\" ... Documentation All packages must be documented. For that, a documentation is already ready-for-use (see its usage ). In particular, every function and method should be properly described using docstrings. Note Comments can also be used but are not encouraged. Indeed, the usage of docstrings + type hints + meaningful variable names can be clearer than comments. Also, we may forget to update the comment, making the code inconsistent with the comments. Still, sometimes, it can be useful for some \"tricky\" parts of the code. Code testing Testing your code becomes crucial when your project gets bigger. Even though it takes some time to implement, it may save you twice this time in debugging. Mostly, it will improve your package's stability and ensure it's always fully functional. See here for an explanation of how to use pytest for your project. Code formatting Tools like black help you format your code. It will make it more readable automatically. See here for an explanation of how to use black for your project. What not to do Never import * from a package. Otherwise, you never know which functions come from which package, which can cause conflicts/bugs. Don't overwrite python builtins and reserved keywords, such as None , list , id , ... Never use the global keyword, which is error-prone. Never write code outside functions/classes. Instead, if you want a script to run code when executed, write it inside a if __name__ == \"__main__\": block. Else, the code would be executed if imported from other python files. Never use a list (or any mutable variable) as a default argument of a function. Indeed, you'll not have the same default argument each time since it can be muted. For instance, if you set default_arg=[] , then it may not be empty at the next call. Instead, use default_arg=None , and you can set it to [] later in the code.","title":"Good practices"},{"location":"good_practices/#naming-conventions","text":"In Python, the most common cases are: snake_case (lower case separated by a _ ), PascalCase (capital letters as a separation, including the first word), and UPPER_CASE . The usages are the following: snake_case for file names, folder names, variables, functions, methods, objects, and your package name. PascalCase to define classes and exceptions. UPPER_CASE for constants. Note For protected methods and internal functions, you can use a _ before, e.g. _my_function . For private methods, use two _ , e.g. __my_method .","title":"Naming conventions"},{"location":"good_practices/#code-readability","text":"We listed below some advice to make the code easier to read. Use _ to name a variable that will not be used: it avoids overloading your brain while reading the code. For instance, if we are only interested in the first value of a tuple: a, _ = f() , or if you don't need the index in a for loop: for _ in range(10): Remove all your unused imports. It makes the code shorter, faster, and easier to read. Avoid having many nested loops. Instead, you can refactor your code to return early or make new functions. We recommend having at most two levels of nested indentation inside functions/methods.","title":"Code readability"},{"location":"good_practices/#type-hints","text":"We recommend using type hints inside each function and method (see PEP guidelines ). Two basic examples can be found below. Note When nothing is returned, None can be used as the function output type. Also, some typings can be imported from typing , e.g. List . from typing import List def greeting ( name : str ) -> None : print ( f 'Hello { name } !' ) def list_multiplication ( l : List [ float ], a : int ) -> List [ float ]: return [ a * x for x in l ] There are many advantages of type hints. In particular, it: enables code completion is less error-prone (since your IDE may help you track bugs before they happen) improves readability guide the user to understand the input/output of any function","title":"Type hints"},{"location":"good_practices/#catching-wrong-inputs","text":"It's great to run a sanity check before running some functions to ensure every argument satisfies some constraints. When the arguments don't meet the constraints, you can return a meaningful error message, saving you a lot of bug-fixing time. from model import MyModel def f ( x : MyModel , a : float ): assert isinstance ( x , MyModel ), f \"The argument 'x' has to be a MyModel object, but found { type ( x ) } .\" assert 0 < a < 1 , f \"The argument 'a' should be included in ]0, 1[, but found { a } .\" ...","title":"Catching wrong inputs"},{"location":"good_practices/#documentation","text":"All packages must be documented. For that, a documentation is already ready-for-use (see its usage ). In particular, every function and method should be properly described using docstrings. Note Comments can also be used but are not encouraged. Indeed, the usage of docstrings + type hints + meaningful variable names can be clearer than comments. Also, we may forget to update the comment, making the code inconsistent with the comments. Still, sometimes, it can be useful for some \"tricky\" parts of the code.","title":"Documentation"},{"location":"good_practices/#code-testing","text":"Testing your code becomes crucial when your project gets bigger. Even though it takes some time to implement, it may save you twice this time in debugging. Mostly, it will improve your package's stability and ensure it's always fully functional. See here for an explanation of how to use pytest for your project.","title":"Code testing"},{"location":"good_practices/#code-formatting","text":"Tools like black help you format your code. It will make it more readable automatically. See here for an explanation of how to use black for your project.","title":"Code formatting"},{"location":"good_practices/#what-not-to-do","text":"Never import * from a package. Otherwise, you never know which functions come from which package, which can cause conflicts/bugs. Don't overwrite python builtins and reserved keywords, such as None , list , id , ... Never use the global keyword, which is error-prone. Never write code outside functions/classes. Instead, if you want a script to run code when executed, write it inside a if __name__ == \"__main__\": block. Else, the code would be executed if imported from other python files. Never use a list (or any mutable variable) as a default argument of a function. Indeed, you'll not have the same default argument each time since it can be muted. For instance, if you set default_arg=[] , then it may not be empty at the next call. Instead, use default_arg=None , and you can set it to [] later in the code.","title":"What not to do"},{"location":"features/black/","text":"Formatting is run with black . As written in their doc, Black gives you speed, determinism, and freedom from pycodestyle nagging about formatting. You will save time and mental energy for more important matters. Blackened code looks the same regardless of the project you're reading. Formatting becomes transparent after a while and you can focus on the content instead. Black makes code review faster by producing the smallest diffs possible. Using Black with the command line At the project's root, you can run the command line below to format all your code. black . Format on save The best option is to format your code on save so that you don't have to think about executing Black anymore. Note After configuring the format on save, it will run Black on your current file each time you save it. On Visual Studio Code Make sure you have the Python extension (from Microsoft). Then, open your settings ( Code -> Preferences -> Settings ) and update the following: Choose black as the provider (search for Python \u203a Formatting: Provider ) Enable formatting on save (search for Editor: Format On Save ). Update the settings Black settings can be found in pyproject.toml under [tool.black] .","title":"Formatting"},{"location":"features/black/#using-black-with-the-command-line","text":"At the project's root, you can run the command line below to format all your code. black .","title":"Using Black with the command line"},{"location":"features/black/#format-on-save","text":"The best option is to format your code on save so that you don't have to think about executing Black anymore. Note After configuring the format on save, it will run Black on your current file each time you save it.","title":"Format on save"},{"location":"features/black/#on-visual-studio-code","text":"Make sure you have the Python extension (from Microsoft). Then, open your settings ( Code -> Preferences -> Settings ) and update the following: Choose black as the provider (search for Python \u203a Formatting: Provider ) Enable formatting on save (search for Editor: Format On Save ).","title":"On Visual Studio Code"},{"location":"features/black/#update-the-settings","text":"Black settings can be found in pyproject.toml under [tool.black] .","title":"Update the settings"},{"location":"features/doc/","text":"Serve locally The documentation can be served locally with mkdocs serve . It will be reloaded each time you save a file. Basic usage We briefly explain how to use and update the documentation. For more details, read about Mkdocs Material . Docs folder docs is the folder containing all the documentation pages. Each page is either a markdown ( .md ) file or a notebook ( .ipynb ) file. The markdown files can also be in subdirectories. Note Once you have added a new file, don't forget to add it in the nav so it becomes accessible (see \"Config file\" below). Config file mkdocs.yml is the config file for the documentation. Inside nav , one can add new pages. For instance: nav : - Home : index.md - Getting Started : getting_started.md - Tutorials : - tutorials/preprocessing.ipynb - tutorials/training.ipynb Writing math You can write some formulas in Latex. You can use the inline syntax ( $...$ or \\(...\\) ) or the block syntax on separate lines ( $$...$$ or \\[...\\] ). For instance, $f_2(x) \\in \\mathbb{R}$ makes \\(f_2(x) \\in \\mathbb{R}\\) . Automatic API If you added docstrings to your code, you could automatically make a nice API of your package. For that, add ::: <package>.<f> in one of your .md files, where <package> is your package name, and <f> is a function/method/class to be documented. This is a docstring example: from typing import List , Dict , Callable , Optional def apply_dict_values ( names : List [ str ], fun : Callable , alpha : Optional [ int ] = 1 ) -> Dict [ str , str ]: \"\"\"Applies a function to all names. The function outputs are returned as values of a dictionary (whose keys are names). Args: names: A list of names. fun: A function to be applied to each name. alpha: Second argument of `fun`. Returns: A dictionary whose keys are names and values results from the function. \"\"\" return { name : fun ( name , alpha ) for name in names } Options can be added, for instance: ::: <package>.<f> options: show_root_heading: true For more details, see Mkdocstrings . Deploy on Github pages To deploy the documentation on Github Pages, you must first push your changes on the master branch. Then, go to the GitHub settings, and choose gh-pages as the branch, and /docs as the folder. It will create a link so that you can access the doc online. Note The default CI is set up to deploy pages when pushing to master , but you can update the .github/workflows/ci.yml file.","title":"Documentation"},{"location":"features/doc/#serve-locally","text":"The documentation can be served locally with mkdocs serve . It will be reloaded each time you save a file.","title":"Serve locally"},{"location":"features/doc/#basic-usage","text":"We briefly explain how to use and update the documentation. For more details, read about Mkdocs Material .","title":"Basic usage"},{"location":"features/doc/#docs-folder","text":"docs is the folder containing all the documentation pages. Each page is either a markdown ( .md ) file or a notebook ( .ipynb ) file. The markdown files can also be in subdirectories. Note Once you have added a new file, don't forget to add it in the nav so it becomes accessible (see \"Config file\" below).","title":"Docs folder"},{"location":"features/doc/#config-file","text":"mkdocs.yml is the config file for the documentation. Inside nav , one can add new pages. For instance: nav : - Home : index.md - Getting Started : getting_started.md - Tutorials : - tutorials/preprocessing.ipynb - tutorials/training.ipynb","title":"Config file"},{"location":"features/doc/#writing-math","text":"You can write some formulas in Latex. You can use the inline syntax ( $...$ or \\(...\\) ) or the block syntax on separate lines ( $$...$$ or \\[...\\] ). For instance, $f_2(x) \\in \\mathbb{R}$ makes \\(f_2(x) \\in \\mathbb{R}\\) .","title":"Writing math"},{"location":"features/doc/#automatic-api","text":"If you added docstrings to your code, you could automatically make a nice API of your package. For that, add ::: <package>.<f> in one of your .md files, where <package> is your package name, and <f> is a function/method/class to be documented. This is a docstring example: from typing import List , Dict , Callable , Optional def apply_dict_values ( names : List [ str ], fun : Callable , alpha : Optional [ int ] = 1 ) -> Dict [ str , str ]: \"\"\"Applies a function to all names. The function outputs are returned as values of a dictionary (whose keys are names). Args: names: A list of names. fun: A function to be applied to each name. alpha: Second argument of `fun`. Returns: A dictionary whose keys are names and values results from the function. \"\"\" return { name : fun ( name , alpha ) for name in names } Options can be added, for instance: ::: <package>.<f> options: show_root_heading: true For more details, see Mkdocstrings .","title":"Automatic API"},{"location":"features/doc/#deploy-on-github-pages","text":"To deploy the documentation on Github Pages, you must first push your changes on the master branch. Then, go to the GitHub settings, and choose gh-pages as the branch, and /docs as the folder. It will create a link so that you can access the doc online. Note The default CI is set up to deploy pages when pushing to master , but you can update the .github/workflows/ci.yml file.","title":"Deploy on Github pages"},{"location":"features/poetry/","text":"Poetry is a package and dependency manager. It creates an environment that is associated with your project. Everything is detailed in their doc , but here we help you get started. Basic command lines Note If you are inside your project, Poetry will automatically detect it. Thus, you don't have to activate your environment to run the commands below. poetry add pandas # Add pandas as a dependency poetry add mkdocs --dev # Add mkdocs as a dev dependency (i.e. not needed to use the package) poetry remove pandas # Remove pandas poetry shell # Activate the environment poetry init # Helps you create pyproject.toml, if not done yet poetry show # List all the available packages poetry show pandas # See the details of a particular package (e.g., its dependencies or its version) poetry install # Install all the project dependencies (if not done yet) poetry update # Get the latest version of your dependencies Activate the poetry environment To activate your new poetry environment, you can choose one of the following: Choose the installed poetry interpreter on Visual Studio Code (it activates your env automatically at each new terminal window). If you didn't provide VS Code the path to poetry virtualenvs, add \"python.venvPath\": <path> in your VS Code user settings file, where path is the output of the following command line: poetry config virtualenvs.path At the root of the project, run poetry shell . Use poetry run before each command line, e.g. poetry run python your_script.py Important All the command lines in this documentation assume that you have activated your environment using one of these methods. E.g., instead of telling you to run poetry run mkdocs serve , we simply say mkdocs serve (note that you need to add poetry run in front of the command only if you have chosen the third option). Install your package on other environments You can install your package on other environments. Activate your environment, then move to the project's root and run pip install -e . to install it with the editable mode. Now, you can import your package when running on this new environment, and it will always consider your code changes thanks to the editable mode (no need to reinstall the package). Details on pyproject.toml and poetry.lock At the root of your directory is a file called pyproject.toml . As written here , \"modern Python packages can contain a pyproject.toml file, first introduced in PEP 518 and later expanded in PEP 517, PEP 621 and PEP 660. This file contains build system requirements and information, which are used by pip to build the package\". Poetry uses this file, and has its own specific group under [tool.poetry] . For instance, the dependencies are listed under [tool.poetry.dev-dependencies] . The poetry.lock file contains information about your dependencies and the correct versions that solve the conflicts. It can be great to commit it to version control so that everyone uses identical package versions.","title":"Poetry usage"},{"location":"features/poetry/#basic-command-lines","text":"Note If you are inside your project, Poetry will automatically detect it. Thus, you don't have to activate your environment to run the commands below. poetry add pandas # Add pandas as a dependency poetry add mkdocs --dev # Add mkdocs as a dev dependency (i.e. not needed to use the package) poetry remove pandas # Remove pandas poetry shell # Activate the environment poetry init # Helps you create pyproject.toml, if not done yet poetry show # List all the available packages poetry show pandas # See the details of a particular package (e.g., its dependencies or its version) poetry install # Install all the project dependencies (if not done yet) poetry update # Get the latest version of your dependencies","title":"Basic command lines"},{"location":"features/poetry/#activate-the-poetry-environment","text":"To activate your new poetry environment, you can choose one of the following: Choose the installed poetry interpreter on Visual Studio Code (it activates your env automatically at each new terminal window). If you didn't provide VS Code the path to poetry virtualenvs, add \"python.venvPath\": <path> in your VS Code user settings file, where path is the output of the following command line: poetry config virtualenvs.path At the root of the project, run poetry shell . Use poetry run before each command line, e.g. poetry run python your_script.py Important All the command lines in this documentation assume that you have activated your environment using one of these methods. E.g., instead of telling you to run poetry run mkdocs serve , we simply say mkdocs serve (note that you need to add poetry run in front of the command only if you have chosen the third option).","title":"Activate the poetry environment"},{"location":"features/poetry/#install-your-package-on-other-environments","text":"You can install your package on other environments. Activate your environment, then move to the project's root and run pip install -e . to install it with the editable mode. Now, you can import your package when running on this new environment, and it will always consider your code changes thanks to the editable mode (no need to reinstall the package).","title":"Install your package on other environments"},{"location":"features/poetry/#details-on-pyprojecttoml-and-poetrylock","text":"At the root of your directory is a file called pyproject.toml . As written here , \"modern Python packages can contain a pyproject.toml file, first introduced in PEP 518 and later expanded in PEP 517, PEP 621 and PEP 660. This file contains build system requirements and information, which are used by pip to build the package\". Poetry uses this file, and has its own specific group under [tool.poetry] . For instance, the dependencies are listed under [tool.poetry.dev-dependencies] . The poetry.lock file contains information about your dependencies and the correct versions that solve the conflicts. It can be great to commit it to version control so that everyone uses identical package versions.","title":"Details on pyproject.toml and poetry.lock"},{"location":"features/pypi/","text":"Publishing on PyPI is very easy with Poetry. If needed, everything is detailed here in their documentation. Note Before publishing a new version of your package, we advise you to ensure all your tests run properly. Configure your PyPI account This step has to be done only once. Create an account on PyPI . Configure your PyPI credentials as written here . (Optional) Setting a new version and release Update the version attribute under the [tool.poetry] group of your pyproject.toml file to set a new version, e.g. version = \"1.3.2\" Create a new tag associated with this version on GitHub (for the tag name, we advise adding a v before the version): git tag <tagname> # create a tag, e.g. v1.3.2 git push origin <tagname> # push a tag to remote On the GitHub interface, go to the \"Release\" section of your repository and \"Draft a new release\" (choose the tag defined above). Publish on PyPI Note If you already published on PyPI: you should make a new version, i.e. at least change the version in your pyproject.toml file, as written above. poetry publish --build","title":"Deploy on PyPI"},{"location":"features/pypi/#configure-your-pypi-account","text":"This step has to be done only once. Create an account on PyPI . Configure your PyPI credentials as written here .","title":"Configure your PyPI account"},{"location":"features/pypi/#optional-setting-a-new-version-and-release","text":"Update the version attribute under the [tool.poetry] group of your pyproject.toml file to set a new version, e.g. version = \"1.3.2\" Create a new tag associated with this version on GitHub (for the tag name, we advise adding a v before the version): git tag <tagname> # create a tag, e.g. v1.3.2 git push origin <tagname> # push a tag to remote On the GitHub interface, go to the \"Release\" section of your repository and \"Draft a new release\" (choose the tag defined above).","title":"(Optional) Setting a new version and release"},{"location":"features/pypi/#publish-on-pypi","text":"Note If you already published on PyPI: you should make a new version, i.e. at least change the version in your pyproject.toml file, as written above. poetry publish --build","title":"Publish on PyPI"},{"location":"features/test/","text":"Tests are run by pytest . Implement new tests Choose or add a new file into the tests/ directory to make a new test. This filename should start with test_ to be targeted by pytest. Into each function of this test file, you can run multiple types of tests, e.g. you can run some assert statements. You can also use some fixtures , i.e. tests whose output will be reused multiple times, which can be very useful when you need to load data or train your model. from mypackage import Model @pytest . fixture def trained_model ( init_data ): model = Model () model . fit () return model # Here, the argument is the previous function name, but it actually contains the function output (i.e., the model) def test_alpha_positive ( trained_model ): assert ( trained_model . alpha > 0 ) . all () def test_is_symmetric ( trained_model ): x1 , x2 = trained_model . x , - trained_model . x y1 , y2 = trained_model ( x1 ), trained_model ( x2 ) assert torch . isclose ( y1 , y2 , atol = 1e-6 ) . all () # To test if two tensor are equal, it's safer to use torch.isclose Run your tests At the project's root, run: pytest","title":"Testing"},{"location":"features/test/#implement-new-tests","text":"Choose or add a new file into the tests/ directory to make a new test. This filename should start with test_ to be targeted by pytest. Into each function of this test file, you can run multiple types of tests, e.g. you can run some assert statements. You can also use some fixtures , i.e. tests whose output will be reused multiple times, which can be very useful when you need to load data or train your model. from mypackage import Model @pytest . fixture def trained_model ( init_data ): model = Model () model . fit () return model # Here, the argument is the previous function name, but it actually contains the function output (i.e., the model) def test_alpha_positive ( trained_model ): assert ( trained_model . alpha > 0 ) . all () def test_is_symmetric ( trained_model ): x1 , x2 = trained_model . x , - trained_model . x y1 , y2 = trained_model ( x1 ), trained_model ( x2 ) assert torch . isclose ( y1 , y2 , atol = 1e-6 ) . all () # To test if two tensor are equal, it's safer to use torch.isclose","title":"Implement new tests"},{"location":"features/test/#run-your-tests","text":"At the project's root, run: pytest","title":"Run your tests"}]}